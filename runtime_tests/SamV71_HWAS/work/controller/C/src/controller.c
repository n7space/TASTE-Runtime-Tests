/* Body file for function Controller
 * Generated by TASTE on 2021-12-02 15:26:53
 * You can edit this file, it will not be overwritten
 * Provided interfaces : InterruptSubscription_Interrupt_Ri, ping, test
 * Required interfaces : InterruptManagement_DisableInterrupt_Pi,
 * InterruptManagement_EnableInterrupt_Pi,
 * InterruptSubscriptionManagement_SubscribeToInterrupt_Pi,
 * RawMemoryAccess_ReadBuffer_Pi, RawMemoryAccess_ReadWord_Pi,
 * RawMemoryAccess_WriteBuffer_Pi, RawMemoryAccess_WriteWord_Pi, pong, result
 * User-defined properties for this function:
 *   |_ TASTE::Is_Component_Type = false
 * Timers              :
 */

#include "controller.h"

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

/// Expected values for test verification
#define EXPECTED_SPI0_CR    (asn1SccWord) 0x00
#define EXPECTED_SPI0_MR    (asn1SccWord) 0xE0091
#define EXPECTED_SPI0_SR    (asn1SccWord) 0x10202
#define EXPECTED_SPI0_RDR   (asn1SccWord) 0x0E0000
#define EXPECTED_SPI0_CSR0  (asn1SccWord) 0x10404B00

#define NUMBER_OF_REGISTERS_TO_CHECK    13
#define SPI0_CR_REGISTER_INDEX          0
#define SPI0_MR_REGISTER_INDEX          1
#define SPI0_RDR_REGISTER_INDEX         2
#define SPI0_SR_REGISTER_INDEX          4
#define SPI0_CSR0_REGISTER_INDEX        12

#define SPI_MSG_LENGTH 30

const asn1SccByteBuffer_elem
    EXPECTED_SPI0_REGISTERS_AFTER_RESET[NUMBER_OF_REGISTERS_TO_CHECK] = {0};

const asn1SccWord EXPECTED_DATA_1 = 0xdecafbad;
const asn1SccWord EXPECTED_DATA_2 = 0x600dcafe;
#define EXPECTED_STATUS_SUCCESS   (asn1SccByte) 0
#define EXPECTED_STATUS_FAIL      (asn1SccByte) 1

/// Global variables needed for tests
uint8_t spiTxBuffer[SPI_MSG_LENGTH] = {"Hello spi!\n"};
uint8_t spiRxBuffer[SPI_MSG_LENGTH];

size_t spiNextByteToSend = 0;
bool msgSent = true;

asn1SccWord testData = EXPECTED_DATA_2;

enum TEST_STATES
{
    TEST_STATES_EXECUTE_SYNC_TESTS = 0,
    TEST_STATES_INIT_READ_MODIFY_WRITE_FAILURE_TEST,
    TEST_STATES_EXECUTE_READ_MODIFY_WRITE_FAILURE_TEST,
    TEST_STATES_INIT_INTERRUPT_SUBSCRIBE_TEST,
    TEST_STATES_EXECUTE_INTERRUPT_SUBSCRIBE_TEST,
    TEST_STATES_TESTS_PASSED,
};

volatile enum TEST_STATES testState = TEST_STATES_EXECUTE_SYNC_TESTS;

/// Setup values for test preparation
#define SETUP_SPI0_CR   (asn1SccByteBuffer_elem) 0x01000001
#define SETUP_SPI0_MR   (asn1SccByteBuffer_elem) EXPECTED_SPI0_MR
#define SETUP_SPI0_SR   (asn1SccByteBuffer_elem) EXPECTED_SPI0_SR
#define SETUP_SPI0_CSR0 (asn1SccByteBuffer_elem) EXPECTED_SPI0_CSR0

enum NVIC_IRQ
{
    NVIC_IRQ_SPI0 = 21,
};

#define PMC_PERIPH_CLOCK_DEFAULT_FREQ 75 //[MHz]
#define SPI_BAUDRATE 1                   //[Mbit]
#define SPI_DELAY_BEFORE_SPCK 0x40
#define SPI_DELAY_BETWEEN_TRANSFERS 0x10

/// PMC registers definitions and constants
#define PMC_OFFSET          (asn1SccSourceAddress) 0x400E0600
#define PMC_PCER0_OFFSET    (asn1SccSourceAddress) 0x0010
#define PMC_PCDR0_OFFSET    (asn1SccSourceAddress) 0x0014
#define PMC_PCSR0_OFFSET    (asn1SccSourceAddress) 0x0018

const asn1SccWordMask WHOLE_REGISTER_MASK = 0xFFFFFFFF;

const asn1SccSourceAddress PMC_PCER0 = PMC_OFFSET + PMC_PCER0_OFFSET;
const asn1SccSourceAddress PMC_PCDR0 = PMC_OFFSET + PMC_PCDR0_OFFSET;
const asn1SccSourceAddress PMC_PCSR0 = PMC_OFFSET + PMC_PCSR0_OFFSET;

const asn1SccWordMask PMC_PCxR0_PID21_SPI0_MASK = 0x00200000;
const asn1SccWordMask PMC_PCxR0_PID11_PIOB_MASK = 0x00000800;
const asn1SccWordMask PMC_PCxR0_PID16_PIOD_MASK = 0x00010000;

/// SPI0 registers definitions and constants
#define SPI0_OFFSET     (asn1SccSourceAddress) 0x40008000
#define SPI_CR_OFFSET   (asn1SccSourceAddress) 0x00
#define SPI_MR_OFFSET   (asn1SccSourceAddress) 0x04
#define SPI_RDR_OFFSET  (asn1SccSourceAddress) 0x08
#define SPI_TDR_OFFSET  (asn1SccSourceAddress) 0x0C
#define SPI_SR_OFFSET   (asn1SccSourceAddress) 0x10
#define SPI_IER_OFFSET  (asn1SccSourceAddress) 0x14
#define SPI_IDR_OFFSET  (asn1SccSourceAddress) 0x18
#define SPI_IMR_OFFSET  (asn1SccSourceAddress) 0x1C
#define SPI_CSR0_OFFSET (asn1SccSourceAddress) 0x30

const asn1SccSourceAddress SPI0_CR      = SPI0_OFFSET + SPI_CR_OFFSET;
const asn1SccSourceAddress SPI0_MR      = SPI0_OFFSET + SPI_MR_OFFSET;
const asn1SccSourceAddress SPI0_RDR     = SPI0_OFFSET + SPI_RDR_OFFSET;
const asn1SccSourceAddress SPI0_TDR     = SPI0_OFFSET + SPI_TDR_OFFSET;
const asn1SccSourceAddress SPI0_SR      = SPI0_OFFSET + SPI_SR_OFFSET;
const asn1SccSourceAddress SPI0_IER     = SPI0_OFFSET + SPI_IER_OFFSET;
const asn1SccSourceAddress SPI0_IDR     = SPI0_OFFSET + SPI_IDR_OFFSET;
const asn1SccSourceAddress SPI0_IMR     = SPI0_OFFSET + SPI_IMR_OFFSET;
const asn1SccSourceAddress SPI0_CSR0    = SPI0_OFFSET + SPI_CSR0_OFFSET;

const asn1SccWordMask SPI_CR_SPIEN_MASK     = (asn1SccWordMask) 0x00000001;
const asn1SccWordMask SPI_CR_SPIDIS_MASK    = (asn1SccWordMask) 0x00000002;
const asn1SccWordMask SPI_CR_SWRST_MASK     = (asn1SccWordMask) 0x00000080;
const asn1SccWordMask SPI_CR_LASTXFER_MASK  = (asn1SccWordMask) 0x01000000;

const asn1SccWordMask SPI_MR_MSTR_MASK          = (asn1SccWordMask) 0x00000001;
const asn1SccWordMask SPI_MR_MODFDIS_MASK       = (asn1SccWordMask) 0x00000010;
const asn1SccWordMask SPI_MR_LLB_MASK           = (asn1SccWordMask) 0x00000080;
const asn1SccWordMask SPI_MR_PCS_SELECT0_MASK   = (asn1SccWordMask) 0x000E0000;

const asn1SccWordMask SPI_TDR_FIRST_BYTE_MASK = (asn1SccWordMask) 0x000000FF;
const asn1SccWordMask SPI_RDR_FIRST_BYTE_MASK = (asn1SccWordMask) 0x000000FF;

const asn1SccWordMask SPI_SR_RDRF_MASK      = (asn1SccWordMask) 0x00000001;
const asn1SccWordMask SPI_SR_TDRE_MASK      = (asn1SccWordMask) 0x00000002;
const asn1SccWordMask SPI_SR_MODF_MASK      = (asn1SccWordMask) 0x00000004;
const asn1SccWordMask SPI_SR_OVRES_MASK     = (asn1SccWordMask) 0x00000008;
const asn1SccWordMask SPI_SR_NSSR_MASK      = (asn1SccWordMask) 0x00000100;
const asn1SccWordMask SPI_SR_TXEMPTY_MASK   = (asn1SccWordMask) 0x00000200;
const asn1SccWordMask SPI_SR_UNDES_MASK     = (asn1SccWordMask) 0x00000400;
const asn1SccWordMask SPI_SR_SPIENS_MASK    = (asn1SccWordMask) 0x00010000;

const asn1SccWordMask SPI_IxR_RDRF_MASK     = (asn1SccWordMask) 0x00000001;
const asn1SccWordMask SPI_IxR_TDRE_MASK     = (asn1SccWordMask) 0x00000002;
const asn1SccWordMask SPI_IxR_MODF_MASK     = (asn1SccWordMask) 0x00000004;
const asn1SccWordMask SPI_IxR_OVRES_MASK    = (asn1SccWordMask) 0x00000008;
const asn1SccWordMask SPI_IxR_NSSR_MASK     = (asn1SccWordMask) 0x00000100;
const asn1SccWordMask SPI_IxR_TXEMPTY_MASK  = (asn1SccWordMask) 0x00000200;
const asn1SccWordMask SPI_IxR_UNDES_MASK    = (asn1SccWordMask) 0x00000400;

const asn1SccWordMask SPI_CSRx_CPOL_MASK        = (asn1SccWordMask) 0x00000001;
const asn1SccWordMask SPI_CSRx_NCPHA_MASK       = (asn1SccWordMask) 0x00000002;
const asn1SccWordMask SPI_CSRx_BITS_8BIT_MASK   = (asn1SccWordMask) 0x00000000;
const asn1SccWordMask SPI_CSRx_SCBR_MASK        = (asn1SccWordMask) 0x0000FF00;
const asn1SccWordMask SPI_CSRx_DLYBS_MASK       = (asn1SccWordMask) 0x00FF0000;
const asn1SccWordMask SPI_CSRx_DLYBCT_MASK      = (asn1SccWordMask) 0xFF000000;

#define SPI_CSRx_SCBR_POS 8
#define SPI_CSRx_DLYBS_POS 16
#define SPI_CSRx_DLYBCT_POS 24

/// PIO (B, C, D) registers definitions and constants
#define PIOB_OFFSET         (asn1SccSourceAddress) 0x400E1000
#define PIOD_OFFSET         (asn1SccSourceAddress) 0x400E1400
#define PIO_PER_OFFSET      (asn1SccSourceAddress) 0x00
#define PIO_PDR_OFFSET      (asn1SccSourceAddress) 0x04
#define PIO_PSR_OFFSET      (asn1SccSourceAddress) 0x08
#define PIO_ABCDSR1_OFFSET  (asn1SccSourceAddress) 0x70
#define PIO_ABCDSR2_OFFSET  (asn1SccSourceAddress) 0x74

#define PIO_NPCS_PIN_MASK (asn1SccSourceAddress) 0x00000004
#define PIO_MISO_PIN_MASK (asn1SccSourceAddress) 0x00100000
#define PIO_MOSI_PIN_MASK (asn1SccSourceAddress) 0x00200000
#define PIO_SPCK_PIN_MASK (asn1SccSourceAddress) 0x00400000

const asn1SccSourceAddress PIOB_PER = PIOB_OFFSET + PIO_PER_OFFSET;
const asn1SccSourceAddress PIOB_PDR = PIOB_OFFSET + PIO_PDR_OFFSET;
const asn1SccSourceAddress PIOB_PSR = PIOB_OFFSET + PIO_PSR_OFFSET;

const asn1SccSourceAddress PIOB_ABCDSR1 = PIOB_OFFSET + PIO_ABCDSR1_OFFSET;
const asn1SccSourceAddress PIOB_ABCDSR2 = PIOB_OFFSET + PIO_ABCDSR2_OFFSET;

const asn1SccSourceAddress PIOD_PER = PIOD_OFFSET + PIO_PER_OFFSET;
const asn1SccSourceAddress PIOD_PDR = PIOD_OFFSET + PIO_PDR_OFFSET;
const asn1SccSourceAddress PIOD_PSR = PIOD_OFFSET + PIO_PSR_OFFSET;

const asn1SccSourceAddress PIOD_ABCDSR1 = PIOD_OFFSET + PIO_ABCDSR1_OFFSET;
const asn1SccSourceAddress PIOD_ABCDSR2 = PIOD_OFFSET + PIO_ABCDSR2_OFFSET;
/// Register value manipulation functions
void Set_register(const asn1SccSourceAddress *const reg,
                  const asn1SccWord valToSet)
{
    asn1SccWordMask tempMask = (asn1SccWordMask)valToSet;
    asn1SccWord tempValue = (asn1SccWord)valToSet;
    controller_RI_RawMemoryAccess_WriteWord_Pi(reg, &tempMask, &tempValue);
}

void Set_register_value(const asn1SccSourceAddress *const reg,
                        const asn1SccWord valToSet, const asn1SccWordMask mask,
                        const uint8_t position)
{
    asn1SccWord value = (valToSet << position) & mask;
    controller_RI_RawMemoryAccess_WriteWord_Pi(reg, &mask, &value);
}

void Reset_register(const asn1SccSourceAddress *const reg,
                    const asn1SccWord valToSet)
{
    asn1SccWordMask tempMask = (asn1SccWordMask)valToSet;
    const asn1SccWord tempValue = ~(valToSet);
    controller_RI_RawMemoryAccess_WriteWord_Pi(reg, &tempMask, &tempValue);
}

asn1SccWord Get_register(const asn1SccSourceAddress *const reg)
{
    asn1SccWord ret = 0;
    controller_RI_RawMemoryAccess_ReadWord_Pi(reg, &WHOLE_REGISTER_MASK, &ret);
    return ret;
}

/// Test functions
inline static void FAIL(void)
{
    static asn1SccCustomInteger result = 0;
    controller_RI_result(&result);
    while(true){}
}

inline static void PASS(void)
{
    static asn1SccCustomInteger result = 1;
    controller_RI_result(&result);
    while(true){}
}

inline static void REGISTER_VALUE_EQUAL(const asn1SccSourceAddress * const reg,
                                        const asn1SccWord expectedValue)
{
    if(Get_register(reg) != expectedValue)
    {
        FAIL();
    }
}

inline static void BUFFER_VALUE_EQUAL(const asn1SccByteBuffer *const actual,
                                      const asn1SccByteBuffer_elem *const expected)
{
    for (int i = 0; i < actual->nCount; i++)
    {
        if (actual->arr[i] != expected[i])
        {
            FAIL();
        }
    }
}

inline static void VALUE_EQUAL(const asn1SccWord actual,
                               const asn1SccWord expected)
{
    if(actual != expected)
    {
        FAIL();
    }
}

/// SPI0 functions
static inline void Spi_pmc_enable()
{
    Set_register(&PMC_PCER0, PMC_PCxR0_PID21_SPI0_MASK);
}

static inline void Spi_pmc_disable()
{
    Reset_register(&PMC_PCER0, PMC_PCxR0_PID21_SPI0_MASK);
}

static inline void Spi_enable()
{
    Set_register(&SPI0_CR, SPI_CR_SPIEN_MASK);
}

static inline void Spi_disable()
{
    Set_register(&SPI0_CR, SPI_CR_SPIDIS_MASK);
}

static inline void Spi_reset()
{
    Set_register(&SPI0_CR, SPI_CR_SWRST_MASK);
}

static inline void Spi_enable_rx_interrupt()
{
    Set_register(&SPI0_IER, SPI_IxR_RDRF_MASK);
}

static inline void Spi_enable_tx_interrupt()
{
    Set_register(&SPI0_IER, SPI_IxR_TXEMPTY_MASK);
}

static inline void Spi_disable_tx_interrupt()
{
    Set_register(&SPI0_IDR, SPI_IxR_TXEMPTY_MASK);
}

static inline void Spi_disable_rx_interrupt()
{
    Set_register(&SPI0_IDR, SPI_IxR_RDRF_MASK);
}

/// SPI0 init functions
void Init_spi_pio_setup()
{
    // Turn on PIOB and PIOD clock
    Set_register(&PMC_PCER0,
                 PMC_PCxR0_PID11_PIOB_MASK | PMC_PCxR0_PID16_PIOD_MASK);
    // Set MISO, MOSI ans SPCK to peripheral B
    Set_register(&PIOD_ABCDSR1,
                 PIO_MISO_PIN_MASK | PIO_MOSI_PIN_MASK | PIO_SPCK_PIN_MASK);
    Reset_register(&PIOD_ABCDSR2,
                   PIO_MISO_PIN_MASK | PIO_MOSI_PIN_MASK | PIO_SPCK_PIN_MASK);
    // Disable MISO, MOSI and SPCK as PIO
    Set_register(&PIOD_PDR,
                 PIO_MISO_PIN_MASK | PIO_MOSI_PIN_MASK | PIO_SPCK_PIN_MASK);
    // Set NPCS to peripheral D
    Reset_register(&PIOB_ABCDSR1, PIO_NPCS_PIN_MASK);
    Set_register(&PIOB_ABCDSR2, PIO_NPCS_PIN_MASK);
    // Disable NPCS as PIO
    Set_register(&PIOB_PDR, PIO_NPCS_PIN_MASK);
}

static inline void Init_spi_set_baudrate(uint32_t valueMbitPerSecond)
{
    Set_register_value(&SPI0_CSR0,
                       (PMC_PERIPH_CLOCK_DEFAULT_FREQ / valueMbitPerSecond),
                        SPI_CSRx_SCBR_MASK, SPI_CSRx_SCBR_POS);
}

static inline void Init_spi_set_dlybs(uint32_t delayBeforeSpck)
{
    Set_register_value(&SPI0_CSR0, delayBeforeSpck, SPI_CSRx_DLYBS_MASK,
                       SPI_CSRx_DLYBS_POS);
}

static inline void Init_spi_set_dlybct(uint32_t delayBetweenTransfers)
{
    Set_register_value(&SPI0_CSR0, delayBetweenTransfers, SPI_CSRx_DLYBCT_MASK,
                       SPI_CSRx_DLYBCT_POS);
}

static inline void Init_spi_config_cr()
{
    /// Set spi0 in LASTXFER
    Set_register(&SPI0_CR, SPI_CR_LASTXFER_MASK);
}

static inline void Init_spi_config_mr()
{
    /// Set spi0 in master mode with mode fault detection disabled, in loopback
    /// mode. Select slave 0
    Set_register(&SPI0_MR, SPI_MR_MSTR_MASK | SPI_MR_MODFDIS_MASK |
                             SPI_MR_LLB_MASK | SPI_MR_PCS_SELECT0_MASK);
}

static inline void Init_spi_config_cpsr0()
{
    /// Set clock polarity (0), phase (0) and slave bits per transfer
    Set_register(&SPI0_CSR0, SPI_CSRx_BITS_8BIT_MASK);

    Init_spi_set_baudrate(SPI_BAUDRATE);
    Init_spi_set_dlybs(SPI_DELAY_BEFORE_SPCK);
    Init_spi_set_dlybct(SPI_DELAY_BETWEEN_TRANSFERS);
}

static inline void Init_spi_setup_pmc_and_pio()
{
    Init_spi_pio_setup();
    Spi_pmc_enable();
}

void Init_spi_config()
{
    Spi_disable();
    Spi_reset();

    Init_spi_config_cr();
    Init_spi_config_mr();
    Init_spi_config_cpsr0();

    asn1SccInterruptNumber irq = NVIC_IRQ_SPI0;
    controller_RI_InterruptManagement_EnableInterrupt_Pi(&irq);
    controller_RI_InterruptSubscriptionManagement_SubscribeToInterrupt_Pi(&irq);
    Spi_enable();
}

/// SPI0 Rx/Tx functions
static inline void Spi0_interrupt_handler_rx(asn1SccWord sr)
{
    if (sr & SPI_SR_RDRF_MASK)
    {
        static size_t receivedByteCount = 0;
        if(receivedByteCount < SPI_MSG_LENGTH)
        {
            uint8_t data = (uint8_t)(0xff & Get_register(&SPI0_RDR));
            spiRxBuffer[receivedByteCount] = data;
            receivedByteCount++;
            if(receivedByteCount == strlen((const char *)spiTxBuffer))
            {
                if(strcmp(spiTxBuffer, spiRxBuffer))
                {
                    FAIL();
                }else
                {
                    /// Increment the state (complete message received)
                    testState++;
                }
            }
        }
        else
        {
            FAIL();
        }
    }
}

static inline void Spi0_interrupt_handler_tx(asn1SccWord sr)
{
    if (sr & SPI_SR_TXEMPTY_MASK)
    {
        if (spiNextByteToSend >= strlen((const char *)spiTxBuffer))
        {
            Spi_disable_tx_interrupt();
            msgSent = true;
        }else
        {
            /// Send another byte
            Set_register_value(&SPI0_TDR,
                               (const asn1SccWord)spiTxBuffer[spiNextByteToSend],
                                SPI_TDR_FIRST_BYTE_MASK, 0);
            spiNextByteToSend++;
        }
    }
}

static inline void Spi0_interrupt_handler()
{
    asn1SccWord sr = Get_register(&SPI0_SR);

    Spi0_interrupt_handler_rx(sr);
    Spi0_interrupt_handler_tx(sr);
}

/// Test functions
static inline void Test_read_write_byte(void)
{
    /// Configure SPI0
    Init_spi_setup_pmc_and_pio();
    Init_spi_config();
    /// Check if SPI0 configuration is as expected
    REGISTER_VALUE_EQUAL(&SPI0_CR, EXPECTED_SPI0_CR);
    REGISTER_VALUE_EQUAL(&SPI0_SR, EXPECTED_SPI0_SR);
    REGISTER_VALUE_EQUAL(&SPI0_MR, EXPECTED_SPI0_MR);
    REGISTER_VALUE_EQUAL(&SPI0_CSR0, EXPECTED_SPI0_CSR0);
}

static inline void Test_read_write_buffer(void)
{
    asn1SccByteBuffer buffer = {.nCount = NUMBER_OF_REGISTERS_TO_CHECK};
    asn1SccByteBuffer actualBuffer = {.nCount = NUMBER_OF_REGISTERS_TO_CHECK};

    /// Enable and reset SPI0
    Init_spi_setup_pmc_and_pio();
    Spi_reset();
    /// Read SPI0 config after reset
    controller_RI_RawMemoryAccess_ReadBuffer_Pi(&SPI0_CR, &buffer);
    /// Check if SPI0 config is as expected
    BUFFER_VALUE_EQUAL(&buffer, EXPECTED_SPI0_REGISTERS_AFTER_RESET);

    /// Enable SPI0
    Spi_enable();
    /// Read SPI0 register value after enabling it
    controller_RI_RawMemoryAccess_ReadBuffer_Pi(&SPI0_CR, &buffer);

    /// Prepare SPI0 configuration
    buffer.arr[SPI0_CR_REGISTER_INDEX] = SETUP_SPI0_CR;
    buffer.arr[SPI0_MR_REGISTER_INDEX] = SETUP_SPI0_MR;
    buffer.arr[SPI0_CSR0_REGISTER_INDEX] = SETUP_SPI0_CSR0;

    /// Configure SPI0
    controller_RI_RawMemoryAccess_WriteBuffer_Pi(&SPI0_CR, &buffer);

    /// Check if SPI0 was properly configured
    buffer.arr[SPI0_CR_REGISTER_INDEX] = EXPECTED_SPI0_CR;
    buffer.arr[SPI0_MR_REGISTER_INDEX] = EXPECTED_SPI0_MR;
    buffer.arr[SPI0_RDR_REGISTER_INDEX] = EXPECTED_SPI0_RDR;
    buffer.arr[SPI0_SR_REGISTER_INDEX] = EXPECTED_SPI0_SR;
    buffer.arr[SPI0_CSR0_REGISTER_INDEX] = EXPECTED_SPI0_CSR0;

    controller_RI_RawMemoryAccess_ReadBuffer_Pi(&SPI0_CR, &actualBuffer);
    BUFFER_VALUE_EQUAL(&actualBuffer, buffer.arr);
}

static inline void Test_read_modify_write_success(void) {
    asn1SccWord actualData = 0x00;
    const asn1SccSourceAddress testDataAddress =
        (const asn1SccSourceAddress)&testData;
    const asn1SccSourceAddress actualDataAddress =
        (const asn1SccSourceAddress)&actualData;

    /// Test if exclusive reading works correctly
    controller_RI_RawMemoryAccess_ExclusiveReadWord_Pi(
        &testDataAddress, &WHOLE_REGISTER_MASK, &actualData);
    VALUE_EQUAL(actualData, EXPECTED_DATA_2);

    /// Test if exclusive write works correctly
    asn1SccByte writeStatus;
    controller_RI_RawMemoryAccess_ExclusiveWriteWord_Pi(
        &testDataAddress, &WHOLE_REGISTER_MASK, &EXPECTED_DATA_1, &writeStatus);
    VALUE_EQUAL(testData, EXPECTED_DATA_1);
    VALUE_EQUAL(writeStatus, EXPECTED_STATUS_SUCCESS);
}

static inline void Init_read_modify_write_failure_test()
{
    const asn1SccSourceAddress testDataAddress =
        (const asn1SccSourceAddress)&testData;
    asn1SccWord actualData;
    controller_RI_RawMemoryAccess_ExclusiveReadWord_Pi(
        &testDataAddress, &WHOLE_REGISTER_MASK, &actualData);
    /// Any kind of interrupt needs to be triggered for exclusive read modify write to fail
    Spi_enable_tx_interrupt();
}

/// This function tests the fulfillment of the requirement ETB_FUN-5030
static inline void Test_read_modify_write_failure()
{
    const asn1SccSourceAddress testDataAddress = (const asn1SccSourceAddress)&testData;

    asn1SccByte writeStatus;
    controller_RI_RawMemoryAccess_ExclusiveWriteWord_Pi(
            &testDataAddress, &WHOLE_REGISTER_MASK, &EXPECTED_DATA_2, &writeStatus);
    VALUE_EQUAL(testData, EXPECTED_DATA_1);
    VALUE_EQUAL(writeStatus, EXPECTED_STATUS_FAIL);
}

static inline void Init_interrupt_subscribe_test()
{
    while(!msgSent) {
    }

    spiNextByteToSend = 0;
    msgSent = false;

    Spi_enable_rx_interrupt();
    Spi_enable_tx_interrupt();
}

static inline void Test_interrupt_subscribe_test()
{
    Spi0_interrupt_handler();
}

static inline void Execute_sync_tests()
{
    Test_read_write_buffer();
    Test_read_write_byte();
    Test_read_modify_write_success();
}

static inline void ExecuteTestState()
{
    switch(testState)
    {
    case TEST_STATES_EXECUTE_SYNC_TESTS:
        Execute_sync_tests();
        testState++;
        break;
    case TEST_STATES_INIT_READ_MODIFY_WRITE_FAILURE_TEST:
        Init_read_modify_write_failure_test();
        testState++;
        break;
    case TEST_STATES_EXECUTE_READ_MODIFY_WRITE_FAILURE_TEST:
        Test_read_modify_write_failure();
        testState++;
        break;
    case TEST_STATES_INIT_INTERRUPT_SUBSCRIBE_TEST:
        Init_interrupt_subscribe_test();
        testState++;
        break;
    case TEST_STATES_EXECUTE_INTERRUPT_SUBSCRIBE_TEST:
        Test_interrupt_subscribe_test();
        /// The state is incremented only after whole message is received.
        break;
    case TEST_STATES_TESTS_PASSED:
        PASS();
        break;
    default:
        break;
    }
}

/// Constroller functions
void controller_startup(void) {}

void controller_PI_InterruptSubscription_Interrupt_Ri(const asn1SccInterrupt_Type *IN_inputparam)
{
    if(IN_inputparam->interrupt == NVIC_IRQ_SPI0)
    {
        ExecuteTestState();
        controller_RI_InterruptManagement_EnableInterrupt_Pi(&IN_inputparam->interrupt);
    }
}

void controller_PI_ping(void)
{
    controller_RI_pong();
}

void controller_PI_test(void)
{
    do
    {
        ExecuteTestState();
    }while(testState < TEST_STATES_EXECUTE_READ_MODIFY_WRITE_FAILURE_TEST);
}
